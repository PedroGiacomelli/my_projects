#include <msp430.h> 

// UART
// P4.4 - TX
// P4.5 - RX

// I2C
// P3.0 ==> SDA
// P3.1 ==> SCL

#define ABERTA  1
#define FECHADA 0
#define DBC     10000

#define FALSE   0
#define TRUE    1

#define PCF_ADR1    0x3F
#define PCF_ADR2    0x27
#define PCF_ADR     PCF_ADR2

#define BR_100K 11  //SMCLK/100K= 11
#define BR_50K  21  //SMCLK/50K = 21
#define BR_10K  105 //SMCLK/10K = 105

void lcd_inic(void);
void lcd_aux(char dado);
void pcf_write(char dado);
void led_vd(void);
void led_VD(void);
void led_vm(void);
void led_VM(void);
void i2c_config(void);
void gpio_config(void);
void delay(long limite);
int pcf_read(void);
int pcf_teste(char adr);

void adc_config(void);
void ta0_config(void);

void usci_a1_config(void);
void ser_int8(unsigned int x);
int ser_read(void);
void ser_char(char x);
void ser_str(char *pt);
void ser_crlf(void);
void ser_dec8(int x);
void ser_dec16(unsigned int x);

int mon_ps1(void);

void lcd_char(char x);
void lcd_cursor(char x);
void lcd_str(char *pt);

int main(void)
{
	WDTCTL = WDTPW | WDTHOLD;	// stop watchdog timer
	
	unsigned int a1,a2,a3,a4,a5,a6,a7,a8,a9,a10;
	int resultado;

	gpio_config();
	i2c_config();
	adc_config();
	usci_a1_config();

	if (pcf_teste(PCF_ADR)==FALSE){
	    led_VM();   //Indicar que não houve ACK
	    while(TRUE); //Travar
	    }
	else led_VD();  //Houve ACK, tudo certo

	lcd_inic();     //Inicializar LCD
	pcf_write(8);   //Acender Back Light

	while(1){
	    //Fase inicial - coleta de medições

	    lcd_cursor(0);
	    lcd_str("Coleta 1 de 2");

	    while(mon_ps1 == FALSE);
	    ADC12CTL0 |= ADC12ENC; //Habilitar a cada sequência
	    while( (ADC12IFG&ADC12IFG4) == 0);
	    a1=ADC12MEM0;
	    a2=ADC12MEM1;
	    a3=ADC12MEM2;
	    a4=ADC12MEM3;
	    a5=ADC12MEM4;

        //Segunda parte da coleta

        lcd_cursor(0);
        lcd_str("Coleta 2 de 2");

	    while(mon_ps1 == FALSE);
	    ADC12CTL0 |= ADC12ENC;
        a6=ADC12MEM0;
        a7=ADC12MEM1;
        a8=ADC12MEM2;
        a9=ADC12MEM3;
        a10=ADC12MEM4;

        lcd_cursor(0);
        lcd_str("Transmitindo...");

        //Envio para o MSP com a ANN
        ser_int8(a1);
        delay(5000);
        ser_int8(a2);
        delay(5000);
        ser_int8(a3);
        delay(5000);
        ser_int8(a4);
        delay(5000);
        ser_int8(a5);
        delay(5000);
        ser_int8(a6);
        delay(5000);
        ser_int8(a7);
        delay(5000);
        ser_int8(a8);
        delay(5000);
        ser_int8(a9);
        delay(5000);
        ser_int8(a10);

        lcd_cursor(0);
        lcd_str("Analisando...");
        //Recepção do resultado da classificação
        resultado = ser_read();

        //Apresentação do resultado no LCD
        lcd_cursor(0);
        lcd_str("Resultado:");
        lcd_cursor(0x40);
        if (resultado == 0) lcd_str("Tudo certo!");         // A numeração aqui usada para
        else if (resultado == 30) lcd_str("Alcool 5%");     //"resultado" é arbitrária
        else if (resultado == 60) lcd_str("Alcool 10%");    //Poderia-se ter utilizado
        else if (resultado == 90) lcd_str("Alcool 15%");    //qualquer outra numeração
        else if (resultado == 120) lcd_str("Alcool 20%");
        else if (resultado == 150) lcd_str("Agua 5%");
        else if (resultado == 180) lcd_str("Agua 10%");
        else if (resultado == 210) lcd_str("Agua 15%");
        else if (resultado == 240) lcd_str("Agua 20%");
        else lcd_str("Erro");
	}

	return 0;
}

int mon_ps1(void){
    static int ps=ABERTA;   //Guarda     passado de PS
    if ( (P2IN&BIT1) == 0){ //Qual o estado atual de PS?
        if (ps==ABERTA){    //Qual o passado de PS?
            delay(DBC);
            ps=FECHADA;
            return TRUE;
        }
    }
    else{
        if (ps==FECHADA){ //Qual o passado de PS?
            delay(DBC);
            ps=ABERTA;
            return FALSE;
        }
    }
    return FALSE;
}

void adc_config(void){
    ADC12CTL0 &= ~ADC12ENC;
    ADC12CTL0 = ADC12ON;
    ADC12CTL1 = ADC12CONSEQ_1 | ADC12SHS_0 | ADC12CSTARTADD_0 | ADC12SSEL_3;
    ADC12MCTL0 = ADC12SREF_0 | ADC12INCH_0;
    ADC12MCTL1 = ADC12SREF_0 | ADC12INCH_1;
    ADC12MCTL2 = ADC12SREF_0 | ADC12INCH_2;
    ADC12MCTL3 = ADC12SREF_0 | ADC12INCH_3;
    ADC12MCTL4 = ADC12SREF_0 | ADC12INCH_4 | ADC12EOS;
    P6SEL |= BIT0|BIT1|BIT2|BIT3|BIT4;
    ADC12CTL0 |= ADC12ENC;
}

void ta0_config(void){
    TA0CTL = TASSEL_1 | MC_1;
    TA0CCTL1 = OUTMOD_6;
    TA0CCR0 = 1024;
    TA0CCR1 = TA0CCR0/2;
}

// Incializar LCD modo 4 bits
void lcd_inic(void){
// Preparar I2C para operar
    UCB0I2CSA = PCF_ADR;    //Endereço Escravo
    UCB0CTL1 |= UCTR |      //Mestre TX
            UCTXSTT;        //Gerar START
    while ( (UCB0IFG & UCTXIFG) == 0);  //Esperar TXIFG=1
    UCB0TXBUF = 0;                      //Saída PCF = 0;
    while ( (UCB0CTL1 & UCTXSTT) == UCTXSTT);   //Esperar STT=0
    if ( (UCB0IFG & UCNACKIFG) == UCNACKIFG)    //NACK?
        while(1);

    // Começar inicialização
    lcd_aux(0);     //RS=RW=0, BL=1
    delay(20000);
    lcd_aux(3);     //3
    delay(10000);
    lcd_aux(3);     //3
    delay(10000);
    lcd_aux(3);     //3
    delay(10000);
    lcd_aux(2);     //2

    // Entrou em modo 4 bits
    lcd_aux(2); lcd_aux(8);     //0x28
    lcd_aux(0); lcd_aux(8);     //0x08
    lcd_aux(0); lcd_aux(1);     //0x01
    lcd_aux(0); lcd_aux(6);     //0x06
    lcd_aux(0); lcd_aux(0xF);   //0x0F

    while ( (UCB0IFG & UCTXIFG) == 0);          //Esperar TXIFG=1
    UCB0CTL1 |= UCTXSTP;                        //Gerar STOP
    while ( (UCB0CTL1 & UCTXSTP) == UCTXSTP);   //Esperar STOP
    delay(50);
}

// Auxiliar inicialização do LCD (RS=RW=0)
// *** Só serve para a inicialização ***
void lcd_aux(char dado){
    while ( (UCB0IFG & UCTXIFG) == 0);      //Esperar TXIFG=1
    UCB0TXBUF = ((dado<<4)&0XF0) | BIT3;    //PCF7:4 = dado;
    delay(50);
    while ( (UCB0IFG & UCTXIFG) == 0);      //Esperar TXIFG=1
    UCB0TXBUF = ((dado<<4)&0XF0) | BIT3 | BIT2; //E=1
    delay(50);
    while ( (UCB0IFG & UCTXIFG) == 0);      //Esperar TXIFG=1
    UCB0TXBUF = ((dado<<4)&0XF0) | BIT3;    //E=0;
}

// Ler a porta do PCF
int pcf_read(void){
    int dado;
    UCB0I2CSA = PCF_ADR;    //Endereço Escravo
    UCB0CTL1 &= ~UCTR;      //Mestre RX
    UCB0CTL1 |= UCTXSTT;    //Gerar START
    while ( (UCB0CTL1 & UCTXSTT) == UCTXSTT);
    UCB0CTL1 |= UCTXSTP;    //Gerar STOP + NACK
    while ( (UCB0CTL1 & UCTXSTP) == UCTXSTP);   //Esperar STOP
    while ( (UCB0IFG & UCRXIFG) == 0);          //Esperar RX
    dado=UCB0RXBUF;
    return dado;
}

// Escrever dado na porta
void pcf_write(char dado){
    UCB0I2CSA = PCF_ADR;    //Endereço Escravo
    UCB0CTL1 |= UCTR |      //Mestre TX
            UCTXSTT;        //Gerar START
    while ( (UCB0IFG & UCTXIFG) == 0);          //Esperar TXIFG=1
    UCB0TXBUF = dado;                           //Escrever dado
    while ( (UCB0CTL1 & UCTXSTT) == UCTXSTT);   //Esperar STT=0
    if ( (UCB0IFG & UCNACKIFG) == UCNACKIFG)    //NACK?
        while(1);                               //Escravo gerou NACK
    UCB0CTL1 |= UCTXSTP;                        //Gerar STOP
    while ( (UCB0CTL1 & UCTXSTP) == UCTXSTP) ;  //Esperar STOP
}

// Testar endereço I2C
// TRUE se recebeu ACK
int pcf_teste(char adr){
    UCB0I2CSA = adr;            //Endereço do PCF
    UCB0CTL1 |= UCTR | UCTXSTT; //Gerar START, Mestre transmissor
    while ( (UCB0IFG & UCTXIFG) == 0);          //Esperar pelo START
    UCB0CTL1 |= UCTXSTP;                        //Gerar STOP
    while ( (UCB0CTL1 & UCTXSTP) == UCTXSTP);   //Esperar pelo STOP
    if ((UCB0IFG & UCNACKIFG) == 0) return TRUE;
    else return FALSE;
}

// Configurar UCSB0 e Pinos I2C
// P3.0 = SDA e P3.1=SCL
void i2c_config(void){
    UCB0CTL1 |= UCSWRST;    // UCSI B0 em reset
    UCB0CTL0 = UCSYNC |     //S�ncrono
            UCMODE_3 |      //Modo I2C
            UCMST;          //Mestre
    UCB0BRW = BR_100K;      //100 kbps
    P3SEL |= BIT1 | BIT0;   // Use dedicated module
    UCB0CTL1 = UCSSEL_2;    //SMCLK e remove reset
}

void lcd_char(char x){
    char esq,dir;
    esq=x & 0xF0;
    dir=(x & 0xF)<<4;
    pcf_write(esq|0x9);
    pcf_write(esq|0xD);
    pcf_write(esq|0x9);
    pcf_write(dir|0x9);
    pcf_write(dir|0xD);
    pcf_write(dir|0x9);
}

void lcd_cursor(char x){
    char esq,dir;
    x |= 0x80;
    esq=x & 0xF0;
    dir= (x & 0xF)<<4;
    pcf_write(esq|0x8);
    pcf_write(esq|0xC);
    pcf_write(esq|0x8);
    pcf_write(dir|0x8);
    pcf_write(dir|0xC);
    pcf_write(dir|0x8);
}

void lcd_str(char *pt){
    char i=0;
    while(pt[i]!=0){
        if (i<0xF) lcd_char(pt[i++]);
        else lcd_cursor(pt[i++]);
    }
}

void led_vd(void) {P4OUT &= ~BIT7;} //Apagar verde
void led_VD(void) {P4OUT |= BIT7;}  //Acender verde
void led_vm(void) {P1OUT &= ~BIT0;} //Apagar vermelho
void led_VM(void) {P1OUT |= BIT0;}  //Acender vermelho

void gpio_config(void){
    P1DIR |= BIT0;  //Led vermelho
    P1OUT &= ~BIT0; //Vermelho Apagado
    P4DIR |= BIT7;  //Led verde
    P4OUT &= ~BIT7; //Verde Apagado
    P2DIR &= ~BIT1;
    P2REN |= BIT1;
    P2OUT |= BIT1;
}

void delay(long limite){
    volatile long cont=0;
    while (cont++ < limite) ;
}

// USCI_A1: Configurar Serial 1 (MSP <=> PC)
// P4.4 = TX (MSP ==> PC)
// P4.5 = RX (MSP <== PC)
void usci_a1_config(void){
    UCA1CTL1 = UCSSEL_2 |   //SMCLK=1.048.576Hz
            UCSWRST;        //UCSI em Reset
    UCA1CTL0 = 0;           //1 Stop
    UCA1BRW  = 109;
    UCA1MCTL = UCBRS_2|UCBRF_0; //UCOS16=0

    P4DIR |= BIT4;          //P4.4 saída
    P4DIR &= ~BIT5;         //P4.5 entrada
    P4SEL |= BIT5 | BIT4;   //Selecionar UART

    PMAPKEYID = 0X02D52;    //Liberar mapeamento
    P4MAP4 = PM_UCA1TXD;    //TX
    P4MAP5 = PM_UCA1RXD;    //RX

    UCA1CTL1 &= ~ UCSWRST;  //UCSI sai de Reset
}

int ser_read(void){
    int dado;
    while ((UCA1IFG & UCRXIFG)==0);
    dado = UCA1RXBUF;
    return dado;
}

void ser_char(char x){
    while ((UCA1IFG & UCTXIFG)==0);
    UCA1TXBUF = x;
}

void ser_int8(unsigned int x){
    while ((UCA1IFG & UCTXIFG)==0);
    UCA1TXBUF = x;
}

void ser_str(char *pt){
    char i=0;
    while(pt[i]!= '\0') ser_char (pt[i++]);
}

void ser_crlf(void){
    ser_char(0xD);
    ser_char(0xA);
}

void ser_dec16(unsigned int x){
    char aux;
    aux= x/10000;
    ser_char(0x30 + aux);
    x-=aux*10000;
    aux= x/1000;
    ser_char(0x30 + aux);
    x-=aux*1000;
    ser_dec8(x);
}

void ser_dec8(int x){
    char aux;
    aux = x/100;
    ser_char(0x30 + aux);
    x-= 100*aux;
    aux=x/10;
    ser_char(0x30+aux);
    x-=10*aux;
    ser_char(0x30+x);
}
